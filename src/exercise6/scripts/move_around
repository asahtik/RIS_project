#! /usr/bin/env python

import rospy
import actionlib
import time

import tf_conversions
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from geometry_msgs.msg import PoseWithCovarianceStamped
from std_msgs.msg import Bool
from hw4.msg import GoalToExplore
import numpy as np
from sound_play.libsoundplay import SoundClient
from geometry_msgs.msg import Twist


class Goal(object):
    def __init__(self, x, y, z, w, greet, spin):
        self.x = x
        self.y = y
        self.z = z
        self.w = w
        self.greet = greet
        self.spin = spin

    def get_distance_to(self, goal):
        """
        return euclidean distance from robot to the goal
        """
        x = np.abs(goal.get_x() - self.x)
        y = np.abs(goal.get_y() - self.y)
        distance = np.sqrt(np.square(x) + np.square(y))
        return distance

    def get_x(self):
        return self.x

    def get_y(self):
        return self.y

    def get_z(self):
        return self.z

    def get_w(self):
        return self.w

    def get_greet(self):
        return self.greet

    def get_spin(self):
        return self.spin

    def to_msg_move_base_goal(self, frame_id="map"):
        msg_goal = MoveBaseGoal()
        msg_goal.target_pose.header.frame_id = frame_id
        msg_goal.target_pose.header.stamp = rospy.Time.now()
        msg_goal.target_pose.pose.position.x = self.get_x()
        msg_goal.target_pose.pose.position.y = self.get_y()
        msg_goal.target_pose.pose.orientation.z = self.get_z()
        msg_goal.target_pose.pose.orientation.w = self.get_w()
        return msg_goal

    def __str__(self):
        return "x: {}, y: {}, z:{}, w:{}".format(self.get_x(), self.get_y(), self.get_z(), self.get_w())

    def __repr__(self):
        return self.__str__()


# GOALS = [
#         Goal(1.97, 3.29, 0.54, 0.84, False, True),
#         Goal(2.71, 1.33, 1, 0, False, True),
#         Goal(4.48, 2.47, -0.81, 0.6, False, True)
#         ]

GOALS = [
        Goal(2.5, 2.45,  0.93, 0.36, False, False),
        Goal(3.05, -0.18, -0.34, 0.94, False, False),
        Goal(-0.2, 0.48, -0.89, 0.45, False, False),
        Goal(1.76, 0.91, -0.96, 0.27, False, False)
        ]


class Robot:
    def __init__(self, goals_todo):
        self.current_x = 0
        self.current_y = 0
        self.current_orientation = 0
        self.goals_todo = goals_todo

        self.timestamp_last_update_amcl = rospy.Time.now()

        rospy.Subscriber('/amcl_pose', PoseWithCovarianceStamped, self.callback_amcl_pose)
        #rospy.Subscriber("/add_goals", GoalToExplore, self.callback_add_goal)

        self.spin_publisher = rospy.Publisher('/cmd_vel_mux/input/teleop', Twist, queue_size=10) # to do a 360 spin

        self.sound_client = SoundClient()
        self.sound_client_voice_type = 'voice_kal_diphone'
        self.sound_client_volume = 0.5

    def callback_amcl_pose(self, data):
        """
        update current internal representation of location of the robot
        """
        self.timestamp_last_update_amcl = rospy.Time.now()
        self.current_x = data.pose.pose.position.x
        self.current_y = data.pose.pose.position.y

        # get current robot orientation
        cam_rotation = data.pose.pose.orientation
        quat = (cam_rotation.x, cam_rotation.y, cam_rotation.z, cam_rotation.w)
        (_, _, angle_cam_in_map_sys) = tf_conversions.transformations.euler_from_quaternion(quat)

        self.current_orientation = angle_cam_in_map_sys
        # print("curr orientation: ", self.current_orientation)

    def callback_add_goal(self, data):
        """
        listen for new goals from face_localizer and add them to GOALS
        """
        unique_goal = True
        # check if there is already a similar goal in the list
        # for goal in self.goals_todo:
        #     x_dif = np.abs(goal.get_x()-data.x)
        #     y_dif = np.abs(goal.get_y()-data.y)
        #     if x_dif < 0.05 or y_dif < 0.05 and not data.greet:
        #         unique_goal = False
        #         break
        if unique_goal:
            rospy.loginfo("I GOT A NEW GOAL FROM A TOPIC! x:{} y:{} z:{} w:{}".format(data.x, data.y, data.z, data.w))
            new_goal = Goal(data.x, data.y, data.z, data.w, data.greet, False)
            self.goals_todo.append(new_goal)

    def get_distance_to(self, goal):
        """
        return euclidean distance from robot to the goal
        """
        x = np.abs(goal.get_x() - self.current_x)
        y = np.abs(goal.get_y() - self.current_y)
        distance = np.sqrt(np.square(x) + np.square(y))
        return distance

    def greet_the_face(self, text_to_say="Hello there."):
        """
        greet the face with sound
        """
        rospy.loginfo("Greeting the face with sound.")
        try:
            self.sound_client.say(text_to_say, self.sound_client_voice_type, self.sound_client_volume)
        except Exception as e:
            rospy.logwarn("sound doesent work: {}".format(e))

    def find_currently_closest_goal(self, also_remove=False):
        """
        find the closest goal to the robot at current moment and optionally delete it from robot goals
        """
        distance_closest = 9999999  # some big num
        goal_closest = None
        for goal in self.goals_todo:
            distance = robot.get_distance_to(goal)
            if distance < distance_closest:
                distance_closest = distance
                goal_closest = goal

        # if also_remove:
        #     # remove a goal object from the robot goal list/queue
        #     self.goals_todo.remove(goal_closest)

            # if the yellow marker is selected and a pink is in proximity, and has not been reached, we delete the pink one
        # if goal_closest.get_greet():
        #     for goal in self.goals_todo:
        #         distance_away = goal_closest.get_distance_to(goal)
        #         if distance_away < 0.2:
        #             self.goals_todo.remove(goal)

        return goal_closest

    def goals_list_not_empty(self):
        return len(self.goals_todo) > 0

    def spin360(self):
        rospy.loginfo("360 spinning initiated.")

        # http://wiki.ros.org/turtlesim/Tutorials/Rotating%20Left%20and%20Right
        speed = 90      # degrees per second
        angle = 360
        vel_msg = Twist()

        angular_speed = speed*2*3.14/360
        relative_angle = angle*2*3.14/360
        vel_msg.angular.z = abs(angular_speed)   # anti-clockwise

        t0 = rospy.Time.now().to_sec()
        # current_angle = 0
        current_angle = self.current_orientation

        # start spinning
        self.spin_publisher.publish(vel_msg)
        rospy.sleep(2)

        # while current_angle < relative_angle:
        #     self.spin_publisher.publish(vel_msg)
        #     t1 = rospy.Time.now().to_sec()
        #     current_angle = angular_speed*(t1-t0)

        # print("bef current orient: {}, should be: {}".format(self.current_orientation, current_angle))
        while abs(self.current_orientation - current_angle) > 0.5:
            self.spin_publisher.publish(vel_msg)
            # print("in  current orient: {}, should be: {}".format(self.current_orientation, current_angle))
            rospy.sleep(0.25)

        # print("out current orient: {}, should be: {}".format(self.current_orientation, current_angle))

        # if the angle is the same as at the beginning -> stop spinning
        vel_msg.angular.z = 0
        self.spin_publisher.publish(vel_msg)
        rospy.loginfo("360 spinning done.")

        # self.spin_publisher.publish(twist)
        


VISITED_GOALS = []
greeted_faces = 0

def move_to_goal_client(robot, move_base_client):
    if robot.goals_list_not_empty():
        goal = robot.find_currently_closest_goal()

        rospy.loginfo("Going to {} goal on position x={}, y={}.".format(goal.get_greet(), goal.get_x(),goal.get_y()))

        robot.timestamp_last_update_amcl = rospy.Time.now() # todo change that.

        goal_msg = goal.to_msg_move_base_goal()
        move_base_client.send_goal(goal_msg)

        '''
        check when was the last message published on amcl_pose while state 
        of the goal is not 3 (which means "Goal reached")
        '''
        unreachable_goal = False
        wait = False
        # todo: I dont really know what this does? please write again in more detail
        while move_base_client.get_state() is not 3:
            now = rospy.Time.now()

            # rospy.loginfo("Current position of the robot: x=%2.2f, y=%2.2f", current_x, current_y)

            # print("now:       {}".format(now.secs - robot.timestamp_last_update_amcl.secs > 1,
            #                            now.secs - robot.timestamp_last_update_amcl.secs))
            # print("should be: {}".format(now - robot.timestamp_last_update_amcl > rospy.Duration(1),
            #                            now - robot.timestamp_last_update_amcl))

            if now.secs - robot.timestamp_last_update_amcl.secs > 3: # todo change that.
                # if now - robot.timestamp_last_update_amcl > rospy.Duration(1):

                unreachable_goal = True
                wait = True
                break

            time.sleep(1)

        if not unreachable_goal:
            wait = move_base_client.wait_for_result()

        # wait_for_result returns true only when goal is reached!
        # http://docs.ros.org/diamondback/api/actionlib/html/simple__action__client_8py_source.html

        robot.goals_todo.remove(goal)

        if not wait:
            rospy.logerr("Action server not available!")
            rospy.signal_shutdown("Action server not available!")
        else:
            VISITED_GOALS.append(goal)

            # spin for 360 degrees
            if goal.get_spin():
                robot.spin360() # blocks further execution until the spinning is done
                # rospy.sleep(8)

            if unreachable_goal:
                rospy.logwarn("Goal can't be reached. Moving on.")
            else:
                if goal.get_greet() is True:
                    robot.greet_the_face()
                    global greeted_faces
                    greeted_faces += 1
                    if greeted_faces==3: rospy.signal_shutdown("Finish")

        # else: print("ALREADY VISITED A SIMILAR GOAL.")


if __name__ == '__main__':
    rospy.init_node('move_to_goal_client', anonymous=True)

    move_base_client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
    move_base_client.wait_for_server()

    robot = Robot(goals_todo=GOALS)

    rate = rospy.Rate(5)
    while not rospy.is_shutdown():
        move_to_goal_client(robot, move_base_client)
        rate.sleep()

    # todo: on finish publish end
    # end_exploring = rospy.Publisher('/end', Bool, queue_size=100)
    # try:
    #     # if result:
    #     end = True
    #     end_exploring.publish(end)
    #     rospy.loginfo("Goal execution done!")
    #
    # except rospy.ROSInterruptException:
    #     rospy.loginfo("Navigation test finished.")
    #
